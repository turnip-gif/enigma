<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ENIGMA Animation Only</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@300;400&display=swap" rel="stylesheet">
    <style>
      html {
        scroll-behavior: smooth;
      }
      html, body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background: black;
        font-family: 'Roboto Mono', monospace;
      }

      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <canvas id="heroCanvas"></canvas>
    <script>
      const canvas = document.getElementById('heroCanvas');
      const ctx = canvas.getContext('2d');
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      const letters = 'ENIGMA'.split('');
      const cols = Math.floor(canvas.width / 50);
      const rows = Math.floor(canvas.height / 50);
      const particles = [];
      const mouse = { x: -1000, y: -1000 };

      class Particle {
        constructor(x, y, isMenu = false, menuLabel = '') {
          this.x = x;
          this.y = y;
          this.char = isMenu ? menuLabel : letters[Math.floor(Math.random() * letters.length)];
          this.glow = isMenu;
          this.baseSize = 14;
          this.size = this.baseSize;
          this.isMenu = isMenu;
          this.menuLabel = menuLabel;
        }
        draw() {
          ctx.font = `${this.size}px 'Roboto Mono'`;
          ctx.fillStyle = this.isMenu ? 'rgba(255, 255, 255, 0.7)' : 'rgba(255, 255, 255, 0.2)';
          ctx.shadowColor = this.glow ? 'rgba(255,255,255,0.8)' : 'rgba(255,255,255,0.3)';
          ctx.shadowBlur = this.glow ? 20 : 6;
          ctx.fillText(this.char, this.x, this.y);
        }
        update() {
          const dx = this.x - mouse.x;
          const dy = this.y - mouse.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (!this.isMenu && dist < 100) {
            this.size = this.baseSize + (100 - dist) * 0.1;
          } else {
            this.size += (this.baseSize - this.size) * 0.1;
          }
        }
      }
        draw() {
          ctx.font = `${this.size}px 'Roboto Mono'`;
          ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
          ctx.shadowColor = this.glow ? 'rgba(255,255,255,0.8)' : 'rgba(255,255,255,0.3)';
          ctx.shadowBlur = this.glow ? 20 : 6;
          ctx.fillText(this.char, this.x, this.y);
        }
        update() {
          const dx = this.x - mouse.x;
          const dy = this.y - mouse.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < 100) {
            this.size = this.baseSize + (100 - dist) * 0.1;
          } else {
            this.size += (this.baseSize - this.size) * 0.1;
          }
        }
      }

      const menuItems = ['About', 'Events', 'Records', 'Contact'];
      const startX = 50;
      const spacingX = 120;
      const menuY = 40;
      const menuLinks = ['#about', '#events', '#records', '#contact'];
      for (let i = 0; i < menuItems.length; i++) {
        const x = startX + i * spacingX;
        const y = menuY;
        const label = menuItems[i];
        const link = menuLinks[i];

        const menuParticle = new Particle(x, y, true, label);

        // Add click detection for canvas menu links
        menuParticle.onClick = function(mx, my) {
          const textWidth = ctx.measureText(label).width;
          const inX = mx > this.x && mx < this.x + textWidth;
          const inY = my < this.y && my > this.y - this.size;
          if (inX && inY) {
            window.location.href = link;
          }
        };

        particles.push(menuParticle);
      }

      canvas.addEventListener('click', (e) => {
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;
        particles.forEach(p => {
          if (p.isMenu && typeof p.onClick === 'function') {
            p.onClick(mx, my);
          }
        });
      });

      for (let y = 90; y < canvas.height; y += 50) {
        for (let x = 20; x < canvas.width; x += 50) {
          particles.push(new Particle(x, y));
        }
      }
      }

      function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        particles.forEach(p => {
          p.update();
          p.draw();
        });
        requestAnimationFrame(animate);
      }

      animate();

      // Randomly flip letters every 200ms
      setInterval(() => {
        const amountToFlip = Math.floor(particles.length * 0.05); // flip ~5% of letters
        for (let i = 0; i < amountToFlip; i++) {
          const index = Math.floor(Math.random() * particles.length);
          const p = particles[index];
          const newChar = letters[Math.floor(Math.random() * letters.length)];
          p.char = newChar;
  p.glow = true;
  setTimeout(() => p.glow = false, 300);
        }
      }, 200);

      window.addEventListener('mousemove', e => {
        mouse.x = e.clientX;
        mouse.y = e.clientY;
      });

      window.addEventListener('resize', () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      });
    </script>
  <section id="about" style="height:100vh; background:#111; color:white; display:flex; align-items:center; justify-content:center; font-size:2rem;">
  <div>About Section</div>
</section>
<section id="events" style="height:100vh; background:#222; color:white; display:flex; align-items:center; justify-content:center; font-size:2rem;">
  <div>Events Section</div>
</section>
<section id="records" style="height:100vh; background:#111; color:white; display:flex; align-items:center; justify-content:center; font-size:2rem;">
  <div>Records Section</div>
</section>
<section id="contact" style="height:100vh; background:#222; color:white; display:flex; align-items:center; justify-content:center; font-size:2rem;">
  <div>Contact Section</div>
</section>
</body>
</html>
